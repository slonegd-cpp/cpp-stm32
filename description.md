# Абстракция над регистрами на С++
Это третья часть тутрориала работы с микроконтроллерами STM32 на С++.

Файлы с кодом из статьи можно ознакомиться тут https://github.com/slonegd-cpp/cpp-stm32/tree/003-periph 

В этой статье (TODO ссылка) описывается абстракция над битовыми полями регистров, которая позволяет за счёт типов при програмировании не задумываться о том в какой регистр что пишется. Вместо этого используются понятные названия сущностей.

В качестве проверки, как всё работаем просто зажжем индикатор. На моей плате (discovery-f7) есть только одна ножка с подключённым индикатором: порт GPIOI ножка порта под номером 1. Её и буду зажигать в этом примере, но дальше будет видно, что не трудно это будет сделать и для всех остальных пинов микроконтроллера.

В stm32, чтобы что-то заработало, в первую очередь надо включить тактирование данной переферии. Управление тактированием производится в группе регистров RCC. (TODO ссылка на документацию). Вот и следует начать с описания нужного регистра. Согласно документации на f7 включение тактирования GPIOI производится 8 битом в регистре AHB1ENR. Всё это достаточно сложно запомнить. Куда лучше такая строка `RCC{}.write<rcc::gpioi::enable>();` Соотвественно, чтобы включить любую другую переферию, в строке нужно лишь заменить её название. Например, чтобы включить usart1 надо замениь `gpioi` на `usart1`, и можно даже не задумываться в каком конкретно это регистре в группе RCC - система типов сама разберёться куда писать.

Итак, необходимо описать группу регистров RCC и всех битовых полей. В данном примере небходим лишь AHB1ENR и я опишу только его, но описание остальных лишь делооформления.

Каждый бит включающий/выключающий переферию должен быть отдельным типом (в данном случае перечислением), в котором должны быть описаны все его возможные состояния и маска, по которой определяется в какой части регистра он находится. Для AHB1ENR это будет выглядеть так:
```c++
namespace stm32f7::rcc {

enum class gpioa     { disable, enable, mask = 1 << 0 };  // Bit 0 GPIOAEN: IO port A clock enable
enum class gpiob     { disable, enable, mask = 1 << 1 };  // Bit 1 GPIOBEN: IO port B clock enable
...
enum class gpioi     { disable, enable, mask = 1 << 8 };  // Bit 8 GPIOIEN: IO port I clock enable
...
enum class otghsulpi { disable, enable, mask = 1 << 30 }; // Bit 30 OTGHSULPIEN: USB OTG HSULPI clock enable

} // namespace stm32f7::rcc {
```
Я привёл лишь часть перечислений, на гитхабе они все. В комментариях текст из документации. Каждый бит в этом регистре принимает лишь 2 значения disable(0)/enable(1). Далее при описании GPIO будут случаю посложнее.

Описание регистра AHB1ENR представлено далее:
```c++
namespace stm32f7::rcc::registers {

struct ahb1enr {
    static constexpr std::size_t offset = 0x30;
    static constexpr auto params = type_pack<
          gpioa, gpiob, gpioc, gpiod, gpioe, gpiof, gpiog, gpioh, gpioi, gpioj, gpiok
        , crc
        , bkpsram
        , dtcmram
        , dma1, dma2, dma2d
        , ethmac, ethmactx, ethmacrx, ethmaptp
        , otghs, otghsulpi
    >{};
};

} // namespace stm32f7::rcc::registers
```
Согласно обощённому описанию регистра в нём должно быть 2 поля:
 * offset - на каком удалении регистр расположен относительно базового адреса группы регистров RCC (для AHB1ENR это 0x30).
 * params - список типов, которые определяют все биты в этом регистре.

 Описание всеё группы регистров RCC
 ```c++
 namespace stm32f7 {

template<class meta>
struct RCC_t final : periph<
      meta
    , rcc::registers::ahb1enr
>{};

struct RCC_meta { static constexpr std::size_t address = 0x4002'3800; };

using RCC = RCC_t<RCC_meta>;

} // namespace stm32f7 {
```
Наследуясь от метакласса periph, который описан в файле https://github.com/slonegd-cpp/cpp-stm32/blob/003-periph/periph.hpp, RCC_t сразу получает все необходимые методы записи в эту группу регистров, при этом будет происходить валидация параметров записи на этапе компиляции. Нельзя будет передать невалидный параметр, не соотвествующий этой группе регистров. Методы следующие:
 * write<args...>() - запись в регистры значений, стирает те значения, который там были
 * update<args...>() - обновляет значения в регистрах, не трогая остальные (для обновления предыдущих ненулевых значений)
 * set<args...>() - впервые устанавливает значения в регистры, не трогая остальные (для инициализации)
, где args... - список значений битов, которые необходимо записать/обновить/установить впервые

Метакласс periph должен быть параметризован классом meta, который хранит базовый адрес группы регистров (для RCC это 0x4002'3800 - смотри документацию), и списком регистров этой группы. В данном случае я оставил только один, но остальные добавляются так же.

Аналогично описывается и переферия GPIO.