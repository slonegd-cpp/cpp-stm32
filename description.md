# Самый маленький размер прошивки для STM32, написанный на С++
Это первая часть тутроиала работы с микроконтроллерами STM32 на С++. Для большего интереса поставлена задача написания минимальной по размеру прошивки, **которая ничего не делает**. Я не люблю пользоваться IDE, которые предлагаются по-умолчанию для работы с этим семейством микроконтроллеров, потому что в них пользователь нажимает кнопки, но не понимает, что происходит на самом деле. Пример в этом туториале можно написать в любом текстовом редакторе. Всё что нужно, gcc компилятор, который может скачать каждый.

---
Предатсавлю сначала саму программу, потом объясню, что в ней значит каждая буква и как её собрать.
```cpp
#include <cstdint> // uintptr_t

int main() {
    volatile auto i{0};
    while (1) {
        i++;
    }
}

struct startup {
    uintptr_t stack_pointer;
    uintptr_t entry_point;
};
__attribute__((section(".startup"))) startup _ {
    .stack_pointer = 0x20050000,
    .entry_point = reinterpret_cast<uintptr_t>(main)
};
```
После компиляции её размер:
```
   text    data     bss     dec     hex filename
     20       8       0      28      1c a.out
```
Любая программа на С++ должна иметь точку входа - функцию. Обычно это функция main, которая возвращает int. Возвращаемое значение нужно для определения операционной системой успешности выполнения программы. Если программа выполнилась успешно, то возвращается 0. В микроконтроллерах программа не заканчивается, и там нет никакой операционной системы, поэтому там не нужно возвращаемое значение. Да и функция может называться как угодно, но тут всё таки осталась main, чтобы меньше запутывать. Всё таки все привыкли именно к main.

Сама функция немного бессмыслена, так как делает совершенно бесполезные вещи. Сначала объявляется локальная переменная `i` и нициализируется нулём. Слово `volatile` необходимо тут, чтобы запретить компилятору её оптимизировать. Без этого слова компилятор просто удалит эту переменную, так как работа с ней никак не влияет на выполнение остальной программы. Второе зарезервированое слово `auto` позволяет компилятору самому определить тип переменной. В данном случае это будет `int`, так как инициализация нулём говорит компилятору, что это именно 0. Если бы надо было задать другой тип, то стоило указать его явно и тогда компилятор неявно приведёт ноль к этому типу. После объявления переменной она просто инкрементируется внутри бесконечного цикла. Таким образом, при отладке можно будет увидеть, что программа работает, переменная будет изменяться.


Согласно `Arm®v7-M Architecture Reference Manual` (раздел `B1.5 Exception mode`), при запуске программы, первые 4 байта прошивки инициализируют указатель на стек, следующие 4 байта указатель на функцию, куда перейдёт управление программой. На самом деле всё несколько сложнее, и далее должна быть целая таблица указателей на функции - обработчики прерываний. И первый обработчик `reset` прерывания, который запускается при старте и при перезапуске программы, который можно вызвать несколькими способами, в том числе аппаратным. В приведённом случае не нужны все остальные прерывания, поэтому их инициализировать нет необходимости.

Для инициализации указателя на стек и указателя на функцию выполнения необходимо создать структуру с этими полями, размером 4 байта. 4 байта - размер указателя в 32 битной архитектуре. Чтобы не задумываться о размерах указателей в архитектуре создан специальный тип `uintptr_t`, который описан в стандартной библиотеке, для чего в первой строке подключен файл с описанием этого типа. Если надо будет скомпилировать эту же программу, к примеру, на 16-битной архитектуре, то `uintptr_t` будет псевдонимом `uint16_t`. К тому же выбор именно этого типа даёт дополнительную подсказку читающему код, что это число является адресом, а не просто целым числом.
```c++
struct startup {
    uintptr_t stack_pointer;
    uintptr_t entry_point;
};
```
Итак, структура `startup` описана. Теперь необходимо её правильно проинициализировать.
```c++
__attribute__((section(".startup"))) startup _ {
    .stack_pointer = 0x20050000,
    .entry_point = reinterpret_cast<uintptr_t>(main)
};
```
Адрес указателя на стек зависит от конкретного микроконтроллера. Cогласно `processor programming manual` того микроконтроллера, который используется (в данном случае stm32f7, но это так же и для других микроконтроллеров stm32), стек устроен так, что его адрес уменьшается по мере заполнения. Поэтому необходимо указать максимальный адрес SRAM в конкретном микроконтроллере. Для приведённого случая (микроконтроллер STM32F7**TODO**) этот адрес 0x20050000, его можно найтив datasheet или reference manual.

Название функции в C++ уже является адресом на неё, поэтому просто этот указатель нужно привести к нужному типу, используя reinterpret_cast.

Для того, чтобы эти данные записались куда необходимо существует расширение в компиляторе gcc, `__attribute__((section(".startup")))` которое заставляет компоновщика расположить её в секции с имененм `.startup`.

Имя экземплятра структуры далее не нужно, поэтому просто `_`.

Помимо самого исходника программы необходим файл компоновщика, где описаны секции памяти. Благодаря этому файлу компановщик точно знает, по какому адресу расположена наша секция `.startup`.

https://www.opennet.ru/docs/RUS/gnu_ld/gnuld-3.html


```
MEMORY {
    FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 1024K
}

SECTIONS {
    .startup : { KEEP(*(.startup)) } >FLASH
    .text    : {      *(.text)     } >FLASH
}
```

