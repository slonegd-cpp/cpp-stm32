# Самый маленький размер прошивки для STM32, написанный на С++
Это первая часть тутроиала работы с микроконтроллерами STM32 на С++. Для большего интереса поставлена задача написания минимальной по размеру прошивки, **которая ничего не делает**. Я не люблю пользоваться IDE, которые предлагаются по-умолчанию для работы с этим семейством микроконтроллеров, потому что в них пользователь нажимает кнопки, но не понимает, что происходит на самом деле. Пример в этом туториале можно написать в любом текстовом редакторе. Всё что нужно, gcc компилятор, который может скачать каждый.

---
Предатсавлю сначала саму программу, потом объясню, что в ней значит каждая буква и как её собрать.
```cpp
#include <cstdint> // uintptr_t

int main() {
    volatile auto i{0};
    while (1) {
        i++;
    }
}

struct startup {
    uintptr_t stack_pointer;
    uintptr_t entry_point;
};
__attribute__((section(".startup"))) startup _ {
    .stack_pointer = 0x20050000,
    .entry_point = reinterpret_cast<uintptr_t>(main)
};
```
После компиляции её размер:
```
   text    data     bss     dec     hex filename
     20       8       0      28      1c a.out
```
Любая программа на С++ должна иметь точку входа - функцию. Обычно это функция main, которая возвращает int. Возвращаемое значение нужно для определения операционной системой успешности выполнения программы. Если программа выполнилась успешно, то возвращается 0. В микроконтроллерах программа не заканчивается, и там нет никакой операционной системы, поэтому там не нужно возвращаемое значение. Да и функция может называться как угодно, но тут всё таки осталась main, чтобы меньше запутывать. Всё таки все привыкли именно к main.

Сама функция немного бессмыслена, так как делает совершенно бесполезные вещи. Сначала объявляется локальная переменная `i` и нициализируется нулём. Слово `volatile` необходимо тут, чтобы запретить компилятору её оптимизировать. Без этого слова компилятор просто удалит эту переменную, так как работа с ней никак не влияет на выполнение остальной программы. Второе зарезервированое слово `auto` позволяет компилятору самому определить тип переменной. В данном случае это будет `int`, так как инициализация нулём говорит компилятору, что это именно 0. Если бы надо было задать другой тип, то стоило указать его явно и тогда компилятор неявно приведёт ноль к этому типу. После объявления переменной она просто инкрементируется внутри бесконечного цикла. Таким образом, при отладке можно будет увидеть, что программа работает, переменная будет изменяться.


Согласно `Arm®v7-M Architecture Reference Manual` (раздел `B1.5 Exception mode`), при запуске программы, первые 4 байта прошивки инициализируют указатель на стек, следующие 4 байта указатель на функцию, куда перейдёт управление программой. На самом деле всё несколько сложнее, и далее должна быть целая таблица указателей на функции - обработчики прерываний. И первый обработчик `reset` прерывания, который запускается при старте и при перезапуске программы, который можно вызвать несколькими способами, в том числе аппаратным. В приведённом случае не нужны все остальные прерывания, поэтому их инициализировать нет необходимости.

Для инициализации указателя на стек и указателя на функцию выполнения необходимо создать структуру с этими полями, размером 4 байта. 4 байта - размер указателя в 32 битной архитектуре. Чтобы не задумываться о размерах указателей в архитектуре создан специальный тип `uintptr_t`, который описан в стандартной библиотеке, для чего в первой строке подключен файл с описанием этого типа. Если надо будет скомпилировать эту же программу, к примеру, на 16-битной архитектуре, то `uintptr_t` будет псевдонимом `uint16_t`. К тому же выбор именно этого типа даёт дополнительную подсказку читающему код, что это число является адресом, а не просто целым числом.
```c++
struct startup {
    uintptr_t stack_pointer;
    uintptr_t entry_point;
};
```
Итак, структура `startup` описана. Теперь необходимо её правильно проинициализировать.
```c++
__attribute__((section(".startup"))) startup _ {
    .stack_pointer = 0x20050000,
    .entry_point = reinterpret_cast<uintptr_t>(main)
};
```
Адрес указателя на стек зависит от конкретного микроконтроллера. Cогласно `processor programming manual` того микроконтроллера, который используется (в данном случае stm32f7, но это так же и для других микроконтроллеров stm32), стек устроен так, что его адрес уменьшается по мере заполнения. Поэтому необходимо указать максимальный адрес SRAM в конкретном микроконтроллере. Для приведённого случая (микроконтроллер STM32F7**TODO**) этот адрес 0x20050000, его можно найтив datasheet или reference manual.

Название функции в C++ уже является адресом на неё, поэтому просто этот указатель нужно привести к нужному типу, используя reinterpret_cast.

Для того, чтобы эти данные записались куда необходимо существует расширение в компиляторе gcc, `__attribute__((section(".startup")))` которое заставляет компоновщика расположить её в секции с имененм `.startup`.

Имя экземплятра структуры далее не нужно, поэтому просто `_`.

Помимо самого исходника программы необходим файл компоновщика, где описано куда расположить секции памяти. Описание языка управления линтером можно почитать тут https://www.opennet.ru/docs/RUS/gnu_ld/gnuld-3.html. Для запуска примера достаточно только указать 2 секции: `.startup`, в которой расположен стартовый код, и `.text` - в которой расположена вся остальная программа.
```
SECTIONS {
    .startup 0x08000000 : { KEEP(*(.startup)) }
    .text               : {      *(.text)     }
}
```
Для секции `.startup` дополнительно указывается адрес, куда расположить секцию. Стандартный загрузчик всех stm32 микроконтроллеров расположен по адресу 0x08000000. Дополнительная команда `KEEP` говорит компоновщику не удалять этот сектор. После секции `.startup` в памяти располагается секция `.text`. Это минимальный скрипт для компоновщика, который позволяет скомпилировать рабочую прошивку. В скриптах, которые распространяют производители намного больше строк. Все они имеют определённое значение, но в данном примере они не нужны.

Теперь необходимо скомпилировать и проанализировать результат. Для компиляции используется следуящая команда:
```
arm-none-eabi-g++ main.cpp -mcpu=cortex-m7 -Os -fno-exceptions -T linker_script.ld -Wl,--gc-sections
```
 * `arm-none-eabi-g++` - свободно распространяемый компилятор. Его легко можно нагуглить и поставить в сиситему.
 * `main.cpp` - файл исходника программы.
 * `-mcpu=cortex-m7` - указание на какую архитектуру произвести компиляцию.
 * `-Os` - флаг оптимизации по размеру. Для приведённого примера можно поставить и без оптимизации `-O0`, так как она довольно простая и оптимизировать тут нечего. Это просто привычка - всегда оптимизировать по размеру в программах для микроконтроллера.
 * `-fno-exceptions` - для системных с++ программ исключения в порядке вещей и по умолчанию они включены, но в мире микроконтроллеров они не приветсвуются, поэтому этим флагом отключаются.
 * `-T linker_script.ld` - указание уомпановщику какой файл скрипта взять.
 * `-Wl,--gc-sections` - тут через запятую указываются флаги компановщика. В данном случае указан лишь `--gc-sections`, так как без него программа не скомпилируется, так как в скрипте не указаны многие секции, которые необходимы по умолчанию. Этот флаг позволяет не указывать эти секции. Так же этот флаг убирает и секцию `.startup`. Чтобы этого не было, в скрипте есть явная команда `KEEP` для этой секции.

Результатом выполнения этой команды будет бинарный файл файл `a.out`. Для преобразования его в бинарный файл прошивки есть команда
```
arm-none-eabi-objcopy -O binary a.out a.bin
```
Тут только одна опция `-O binary` - указание, что выходной файл должен быть бинарного формата (есть ещё распрастраннёный ihex формат, но для прошивки в stm32 используется именно бинарный).

Результатом выполнения команды будет файл `a.bin`, который можно уже прошивать в микроконтроллер. Если вывести его в терминал, при этом преобразовать байты в 16-ричный формат по 4 байта, то результат будет следующий.
```
0000000 20050000 08000011 bf00b5f8 bf00b5f8
0000020 2300b082 9b019301 e7fb3301
0000034
```
Первое число `0x20050000` - адрес указателя на стек. Именно такое значение было указано в поле `startap::stack_pointer`. Далее должен идти указатель на функцию main `0x80000011`. Действительный адрес функции `main` будет `0x80000010`, в чём можно будет убедиться далее. Компилятор сам установил крайний бит, потому что этого требует архитектура, а какая архитектура используется было указано в флагах компиляции.

Но рассматривать байтики в таком виде не очень удобно. Для дизасемлирования можно воспользоваться командой 
```
arm-none-eabi-objdump --disassemble a.out
```
Её вывод будет следующим:
```
a.out:     file format elf32-littlearm


Disassembly of section .init:

08000008 <_init>:
 8000008:       b5f8            push    {r3, r4, r5, r6, r7, lr}
 800000a:       bf00            nop

Disassembly of section .fini:

0800000c <_fini>:
 800000c:       b5f8            push    {r3, r4, r5, r6, r7, lr}
 800000e:       bf00            nop

Disassembly of section .text.startup:

08000010 <main>:
 8000010:       b082            sub     sp, #8
 8000012:       2300            movs    r3, #0
 8000014:       9301            str     r3, [sp, #4]
 8000016:       9b01            ldr     r3, [sp, #4]
 8000018:       3301            adds    r3, #1
 800001a:       e7fb            b.n     8000014 <main+0x4>
```
Секции `.init` и `.fini` компилятор добавил самостоятельно. Так же видно, что функция `main` расположена по адресу `0x08000010` - именно отсюда начинается выполнение программы.
 * `sub     sp, #8` - смещает указатель стека на 8 байт. Другими словами резервирует 8 байт на локальные переменные.
 * `movs    r3, #0` - обнуление регистра r3.
 * `str     r3, [sp, #4]` - сохранение на стеке (со смещением 4 байта) того, что храниться в регистре r3, а там на этом шаге выполнения программы 0. Это и есть переменная i.
 *  `ldr     r3, [sp, #4]` - загрузка значения переменной i в регистр r3. Поскольку i была помечена как `volatile`, компилятору это указание, что с момента сохранения этой переменной в последний раз она могла измениться, поэтому он загружает её снова.
 * `adds    r3, #1` - инкремент значения в регистре r3.
 * `b.n     8000014 <main+0x4>` - безусловный переход по адресу `0x8000014` или на 4 байта от начала выполнения функции main. По адресу `0x8000014` опять происходит сохранение значения регистра r3 в локальную переменную на стеке и всё начинает повторяться.

Чтобы каждый раз не писать длинную строку команды компиляции можно воспользоваться утилитой make. Она устроена очень просто. В `Makefile` записываются имя цели, знак ":", и на следующей строке через табуляцию выполняемые команды. Цель `all` это цель по умолчанию.